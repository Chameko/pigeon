use crate::{
    pipeline::{QuadPipe, TrianglePipe, Render, RenderInformation}, graphics::{Drawable, Breakdown},
};
use parrot::{Painter, pipeline::Blending, transform::{ScreenSpace, WorldSpace}, painter::{PassOp}};
use pollster::FutureExt;
use itertools::Itertools;
use std::cmp::Ordering;
use std::time::Instant;
use euclid::{Transform3D, Size2D};

pub const OPENGL_TO_WGPU_MATRIX: Transform3D<f32, WorldSpace, WorldSpace> = Transform3D::new(
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.5, 0.0,
    0.0, 0.0, 0.5, 1.0,
);

/// Contains the managing code for pigeon as well as the draw functions. It comes with a basic
/// version of [`Pigeon`] able to draw the basic primatives but its recommended that you create your
/// own using the [`pigeon!`] macro.
/// 
/// ## Drawing
/// To draw in pigeon, call the [`draw`] function. It takes in a reference to a function that you'll
/// create that takes a [`Container`] as an input. In your function you can use the other functions
/// generated by the [`pigeon!`] macro for each pipeline that add any shapes that can be broken down
/// into that pipelines vertices and add them to the [`Container`]. Everything in the [`Container`] 
/// gets drawn to the screen.

/// Macro to create a pigeon, the manager, and various draw functions.
/// the pigoen struct as input.
/// 
/// A normal [`Pigeon`] is generated from this in the library, but this marco allows you to extend pigeon with your own pipelines.
/// 
/// # Usage
/// The primary use for this is to create an instance of pigeon which contains all the pipelines you specified.
/// The macro also creates a [Container] to contain the [`Breakdown`] generated by the shapes for the pipelines
/// Finally, it creates the relevent funcitons to append a graphic to the container
/// 
/// You assign each pipeline a "name", which is what the [`Breakdown`] generated for it in [Container] are under and what the field names for the pipelines in [Pigeon] are called.
/// You can also use [pigeon_parrot] custom pipeline feature 
/// 
/// # Format
/// In genral:
/// ```rust
/// pigeon!(PipelineType => name, AnotherPipeline => another_name | CustomPipeline : func_for_pipeline => name, AnotherCustom : func => another_custom_name)
/// ```
/// With just customs:
/// ```rust
/// pigeon!(| CustomPipeline : func_for_pipeline => name, AnotherCustom : func => another_custom_name)
/// ```
/// With no customs
/// ```rust
/// pigeon!(PipelineType => name, AnotherPipeline => another_name |)
/// ```
/// 
/// # Example
/// ```rust
/// pigeon!(QuadPipe => quad, TrianglePipe => triangle);
/// ```
/// 
/// This creates a [Pigeon] and [Container] with the [`QuadPipe`] and [`TrianglePipe`] pipelines, with the field names quad and triangle.
/// It also creates the fn draw_quad and draw_triangle to append graphics that breakdown for [`QuadPipe`] and [`TrianglePipe`]
macro_rules! pigeon {
    ($( $pipe:ty => $name:ident ),* | $($cust_pipe:ty : $func:ident => $cust_name:ident),* ) => {
        /// The manager for pigeon. Contains the important things like the pipelines and the [`Painter`]
        #[derive(Debug)]
        pub struct Pigeon {
            pub paint: Painter,
            pub screen: Size2D<f32, WorldSpace>,
            pub frame_time: u128,
            $(pub $name: $pipe,
            )*
            $(pub $cust_name: $cust_pipe,
            )*
        }

        impl Pigeon {
            pub fn new(surface: wgpu::Surface, instance: &wgpu::Instance, size: Size2D<f32, WorldSpace>, sample_count: u32) -> Self {
                let paint = Painter::for_surface(surface, instance, sample_count).block_on().unwrap();
                $(let $name = paint.pipeline::<$pipe>(Blending::default(), paint.preferred_format(), Some(&format!("{} shader", stringify!($name))));
                )*
                $(
                    let $cust_name = paint.custom_pipeline::<$cust_pipe, _>(Some(&format!("{} shader", stringify!($cust_name))), $func);
                )*
        
                Self {
                    paint,
                    screen: size,
                    frame_time: 0,
                    $($name,
                    )*
                    $($cust_name,
                    )*
                }
            }

            pub fn update_size(&mut self, size: impl Into<Size2D<f32, WorldSpace>>) {
                self.screen = size.into();
            }
        }

        /// Used as an intermediate, it contains the breakdowns for various pipelines
        #[derive(Debug)]
        pub struct Container {
            $(pub $name: Vec<Breakdown<<$pipe as Render>::Vertex>>,
            )*
            $(pub $cust_name: Vec<Breakdown<<$cust_pipe as Render>::Vertex>>,
            )*
        }

        impl Container {
            pub fn new() -> Self {
                Self {
                    $($name: vec![],
                    )*
                    $($cust_name: vec![],
                    )*
                }
            }

            pub fn is_updates(&self) -> bool {
                if $(self.$name.len() > 0 || )* $(self.$cust_name.len() > 0 ||)* false {
                    true
                } else {
                    false
                }
            }
        }

        pub fn draw<F>(pigeon: &mut Pigeon, draw_fn: F)
        where
        F: FnOnce(&mut Container),
        {
            let mut cont = Container::new();

            log::debug!("Calling user's draw function");

            let st = Instant::now();
            // Allow the user to populate the container
            draw_fn(&mut cont);

            log::debug!("Sorting container");
            // sort container contents by texture.
            $(
                cont.$name = cont.$name.into_iter().sorted_by(|b1, b2| {
                    if let Some(t1) = &b1.texture {
                        if let Some(t2) = &b2.texture {
                            // Some, Some
                            if t1.id == t2.id {
                                Ordering::Equal
                            } else if t1.id > t2.id{
                                Ordering::Greater
                            } else {
                                Ordering::Less
                            }
                        } else {
                            // Some, None
                            Ordering::Greater
                        }
                    } else if b2.texture.is_some() {
                        // None, Some
                        Ordering::Less
                    } else {
                        // None, None
                        Ordering::Equal
                    }
                }).collect();
            )*
            $(
                cont.$cust_name = cont.$cust_name.into_iter().sorted_by(|b1, b2| {
                    if let Some(t1) = &b1.texture {
                        if let Some(t2) = &b2.texture {
                            if Rc::ptr_eq(&t1, &t2) {
                                Ordering::Equal
                            } else {
                                Ordering::Greater
                            }
                        } else {
                            // Some, None
                            Ordering::Greater
                        }
                    } else if let Some(_) = &b2.texture {
                        // None, Some
                        Ordering::Less
                    } else {
                        // None, None
                        Ordering::Equal
                    }
                }).collect();
            )*
            log::info!("Sort time >> {}ms", st.elapsed().as_millis());
            log::debug!("Sorted container >> {:?}", cont);

            // Generate appropriate matrix info
            let ortho: Transform3D<f32, WorldSpace, ScreenSpace> = Transform3D::ortho(-pigeon.screen.width/2.0, pigeon.screen.width/2.0, -pigeon.screen.height/2.0, pigeon.screen.height/2.0, 50.0, -50.0);
            let ortho = OPENGL_TO_WGPU_MATRIX.then(&ortho);
            log::debug!("Transform matrix >> {:?}", ortho);

            let ft = Instant::now();

            // Only render if there are any updates
            if cont.is_updates() {
                // Setup frame
                let mut frame = pigeon.paint.frame();
                let current_surface = pigeon.paint.current_frame().unwrap();
                {
                    let mut pass = frame.pass(PassOp::Clear(parrot::color::Rgba::new(0.1, 0.2, 0.3, 1.0)), &current_surface, None);
                    // call pipelines render function
                    $(
                        // Only render if we have something to render
                        if cont.$name.len() > 0 {
                            log::info!("Rendering for pipeline >> {} ---------------", stringify!($pipe));
                            let prep: RenderInformation<<$pipe as Render>::Vertex> = (cont.$name, ortho);
                            pigeon.paint.update_pipeline(&mut pigeon.$name, prep);
                            #[allow(unused_variables)]
                            let pass = pigeon.$name.render(&mut pigeon.paint, &mut pass);
                        }
                    )*
                    $(
                        // Only render if we have something to render
                        if cont.$cust_name.len() > 0 {
                            let prep: RenderInformation<<$cust_pipe as Render>::Vertex> = (cont.$cust_name, ortho);
                            pigeon.paint.update_pipeline(&mut pigeon.$cust_name, prep);
                            #[allow(unused_variables)]
                            let pass = pigeon.$cust_name.render(&mut pigeon.paint, &mut pass);
                        }
                    )*
                }

                pigeon.paint.present(frame);
            }

            pigeon.frame_time = ft.elapsed().as_millis();
            log::info!("Frame time >> {}ms", pigeon.frame_time);
        }
        
        paste::paste! {
            $(
                pub fn [<draw_$name>](cont: &mut Container, graphics: Vec<&dyn Drawable<Pipeline = $pipe>>) {
                    let mut graphics = graphics.iter().map(|g| g.breakdown()).collect();
                    cont.$name.append(&mut graphics)
                }
            )+
        }
    };
}

pigeon!(TrianglePipe => triangle, QuadPipe => quad |);