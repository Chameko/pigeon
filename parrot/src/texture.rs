use euclid::{Size2D, Rect, Point2D};

use crate::{
    binding::Bind, device::Device, transform::ScreenSpace, color::Color
};

/// Parrots texture types. Note that textures coordinate system has the y-axis pointing down and the origin at the top right

#[derive(Debug)]
/// A texture
pub struct Texture {
    /// Wrapped wgpu value
    pub wgpu: wgpu::Texture,
    /// A texture view generated by the texture
    pub view: wgpu::TextureView,
    pub extent: wgpu::Extent3d,
    /// Format of texture
    pub format: wgpu::TextureFormat,
    /// Size of the texture
    pub size: Size2D<u32, ScreenSpace>
}

impl Texture {
    /// Clears a texture with a singular color
    pub fn clear<T> (
        texture: &Texture,
        colour: T,
        device: &Device
    ) where 
    T: Color + Clone + Copy,
    {
        let capacity = texture.size.to_usize().area();
        let mut t_pixels : Vec<T> = Vec::with_capacity(capacity);
        t_pixels.resize(capacity, colour);
        
        Self::fill(
            texture,
            t_pixels.as_slice(),
            &device,
            
        )
    }
    
    /// Fill a texture with texture pixels
    pub fn fill<T> (
        texture: &Texture,
        t_pixels: &[T],
        device: &Device
    ) where
    T: bytemuck::Pod + Clone + Copy + 'static + Color,
    {
        assert!(
            t_pixels.len() as u32 >= texture.size.area(),
            "Fatal: incorrect length for t_pixel buffer. Pixels length: {} || Required buffer length: {}", t_pixels.len(), texture.size.area()
        );
        
        let t_pixels = bytemuck::cast_slice(t_pixels);
        
        Self::copy(
            texture,
            texture.size,
            Point2D::new(0, 0),
            &device.queue,
            t_pixels,
            t_pixels.len() as u32 / texture.extent.height,
            texture.extent
        )
    }
    
    /// Transfer texture pixels to a rect in a texture.
    pub fn transfer<T>(
        texture: &Texture,
        t_pixels: &[T],
        dest_rect: Rect<u32, ScreenSpace>,
        device: &Device,
    ) where
    T: bytemuck::Pod + Clone + Copy + 'static,
    {
        assert!(
            dest_rect.area() <= texture.size.area(),
            "Fatal: transfer size must be <= to the texture size"
        );
        
        let t_pixels: &[u8] = bytemuck::cast_slice(t_pixels);
        
        let extent = wgpu::Extent3d {
            width: dest_rect.width(),
            height: dest_rect.height(),
            depth_or_array_layers: 0,
        };
        Self::copy(
            &texture,
            dest_rect.size,
            dest_rect.origin,
            &device.queue,
            t_pixels,
            t_pixels.len() as u32 / texture.extent.height * 4 as u32,
            extent
        )
    }
    
    /// Transfer one section of a texture to another. 
    pub fn blit(
        &self,
        src: Rect<u32, ScreenSpace>,
        dst: Rect<u32, ScreenSpace>,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        assert!(
            src.area() == dst.area(),
            "Source and destination rectangles must be of the same size"
        );
        
        encoder.copy_texture_to_texture(
            wgpu::ImageCopyTexture {
                texture: &self.wgpu,
                mip_level: 0,
                origin: wgpu::Origin3d {
                    x: src.origin.x,
                    y: src.origin.y,
                    z: 0,
                },
                aspect: wgpu::TextureAspect::All,
            },
            wgpu::ImageCopyTexture {
                texture: &self.wgpu,
                mip_level: 0,
                origin: wgpu::Origin3d {
                    x: dst.origin.x,
                    y: dst.origin.y,
                    z: 0,
                },
                aspect: wgpu::TextureAspect::All,
            },
            wgpu::Extent3d {
                width: src.width(),
                height: src.height(),
                depth_or_array_layers: 0,
            }
        )
    }

    /// Note that the rect is only used for its origin and height which are in wgpu coordinates.
    fn copy (
        texture: &Texture,
        size: Size2D<u32, ScreenSpace>,
        origin: Point2D<u32, ScreenSpace>,
        queue: &wgpu::Queue,
        t_pixels: &[u8],
        bytes_per_row: u32,
        extent: wgpu::Extent3d,
    ) {
        queue.write_texture(
            wgpu::ImageCopyTexture {
                texture: &texture.wgpu,
                mip_level: 0,
                origin: wgpu::Origin3d {
                    x: origin.x,
                    y: origin.y,
                    z: 0
                },
                aspect: wgpu::TextureAspect::All
            },
            t_pixels,
            wgpu::ImageDataLayout {
                offset: 0,
                bytes_per_row: std::num::NonZeroU32::new(bytes_per_row),
                rows_per_image: std::num::NonZeroU32::new(size.height),
            },
            extent, 
        )
    }
}

impl Bind for Texture {
    fn binding(&self, index: u32) -> wgpu::BindGroupEntry {
        wgpu::BindGroupEntry {
            binding: index,
            resource: wgpu::BindingResource::TextureView(&self.view)
        }
    }
}
